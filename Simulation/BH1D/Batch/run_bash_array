#!/bin/bash

# relies on some assumption on where the files are stored

# 2 inputs: Where the metaconfig file is stored (relative to run_bash_array)
# and the name of the folder we are going to create to store the results
input_file=$1
output_folder=$2
walltime=${3:-24}
nb_cpus=${4:-1}
mem=${5:-32}

# Where the final results are going to be stored
output_path="$WORK/ResBH1D/""${output_folder}"
mkdir -p "$output_path"

# amend (such that it points to the right output place) and store the meta 
# config in the output folder
output_python_path="Output/${output_folder}" #relative path used by python to store res
input_store_file="$output_path"/"input_bash"
prefix_res=$(grep '^_OUT_PREFIX' "${input_file}" | sed "s/.*'\(.*\)'/\\1/")
Beg=$(grep '^_OUT_COUNTER' "${input_file}" | sed "s/_OUT_COUNTER //")
sed "s@^_OUT_FOLDER.*\$@_OUT_FOLDER '${output_python_path}'@" "${input_file}" >"${input_store_file}"


# generate the configs (from the input file) and store them in a subfolder of
# the output file. Then assign to the variable N the number of configs found
# configs are stored as /Config/config_res0 /Config/config_res1 etc..
module load anaconda3/personal  
source activate py36q
config_store_folder="$output_path"/"Config"
config_store_name="${config_store_folder}/""config_""${prefix_res}"
python run_batch.py "gen_configs_custom" "${input_store_file}" "${config_store_folder}"
N=$(ls "${config_store_folder}" | wc -l)
End=$((Beg+N-1))

cd "${output_path}"

# Create Array job
cat >to_qsub <<ScriptEnd
#!/bin/bash
#PBS -J ${Beg}-${End} 
#PBS -l walltime=${walltime}:00:00,select=1:ncpus=${nb_cpus}:mem=${mem}gb

cp -r \$HOME/Testing/QuantumSimulation/ .
module load anaconda3/personal
source activate py36q
cd QuantumSimulation/Simulation/BH1D/Batch
pbsexec python run_batch.py "run_one_config" "${config_store_name}\${PBS_ARRAY_INDEX}.txt"

cp -r "${output_python_path}" "${output_path}"
ScriptEnd


# Submit

qsub to_qsub

# Copy back to WORK directory
# cp to_qsub "${output_path}"/
# rm to_qsub
